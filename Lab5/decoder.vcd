$date
	Sat Feb 18 16:02:43 2017
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module decoder_test $end
$var wire 3 ! alu_op [2:0] $end
$var wire 1 " alu_src2 $end
$var wire 1 # except $end
$var wire 1 $ rd_src $end
$var wire 1 % writeenable $end
$var reg 6 & funct [5:0] $end
$var reg 6 ' opcode [5:0] $end
$scope module decoder $end
$var wire 1 ( add $end
$var wire 1 ) addi $end
$var wire 3 * alu_op [2:0] $end
$var wire 1 " alu_src2 $end
$var wire 1 + andi $end
$var wire 1 # except $end
$var wire 6 , funct [5:0] $end
$var wire 1 - myand $end
$var wire 1 . mynor $end
$var wire 1 / myor $end
$var wire 1 0 myxor $end
$var wire 6 1 opcode [5:0] $end
$var wire 1 2 ori $end
$var wire 1 3 r $end
$var wire 1 $ rd_src $end
$var wire 1 4 sub $end
$var wire 1 % writeenable $end
$var wire 1 5 xori $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
05
04
13
02
b0 1
00
0/
0.
0-
b100000 ,
0+
b10 *
0)
1(
b0 '
b100000 &
1%
0$
0#
0"
b10 !
$end
#10
b11 !
b11 *
0(
14
b100010 &
b100010 ,
#20
b100 !
b100 *
04
1-
b100100 &
b100100 ,
#30
b101 !
b101 *
0-
1/
b100101 &
b100101 ,
#40
b110 !
b110 *
0/
1.
b100111 &
b100111 ,
#50
b111 !
b111 *
0.
10
b100110 &
b100110 ,
#60
b10 !
b10 *
0#
1"
1$
1%
00
b1000 '
b1000 1
03
1)
#70
b100 !
b100 *
b1100 '
b1100 1
0)
1+
#80
b101 !
b101 *
b1101 '
b1101 1
0+
12
#90
b111 !
b111 *
b1110 '
b1110 1
02
15
#100
1#
0%
b0 !
b0 *
0"
0$
b100100 &
b100100 ,
b1 '
b1 1
05
#110
