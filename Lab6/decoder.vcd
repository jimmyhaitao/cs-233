$date
	Sun Mar  5 16:38:34 2017
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module decoder_test $end
$var wire 1 ! addm $end
$var wire 3 " alu_op [2:0] $end
$var wire 1 # alu_src2 $end
$var wire 1 $ byte_load $end
$var wire 1 % byte_we $end
$var wire 2 & control_type [1:0] $end
$var wire 1 ' except $end
$var wire 1 ( lui $end
$var wire 1 ) mem_read $end
$var wire 1 * rd_src $end
$var wire 1 + slt $end
$var wire 1 , word_we $end
$var wire 1 - writeenable $end
$var reg 6 . funct [5:0] $end
$var reg 6 / opcode [5:0] $end
$var reg 1 0 zero $end
$scope module decoder $end
$var wire 1 1 ADDM $end
$var wire 1 2 LUI $end
$var wire 1 3 SLT $end
$var wire 1 4 add $end
$var wire 1 5 addi $end
$var wire 1 ! addm $end
$var wire 3 6 alu_op [2:0] $end
$var wire 1 # alu_src2 $end
$var wire 1 7 andi $end
$var wire 1 8 beq $end
$var wire 1 9 bne $end
$var wire 1 $ byte_load $end
$var wire 1 % byte_we $end
$var wire 2 : control_type [1:0] $end
$var wire 1 ' except $end
$var wire 6 ; funct [5:0] $end
$var wire 1 < j $end
$var wire 1 = jr $end
$var wire 1 > lbu $end
$var wire 1 ( lui $end
$var wire 1 ? lw $end
$var wire 1 ) mem_read $end
$var wire 1 @ myand $end
$var wire 1 A mynor $end
$var wire 1 B myor $end
$var wire 1 C myxor $end
$var wire 6 D opcode [5:0] $end
$var wire 1 E ori $end
$var wire 1 F r $end
$var wire 1 * rd_src $end
$var wire 1 G sb $end
$var wire 1 + slt $end
$var wire 1 H sub $end
$var wire 1 I sw $end
$var wire 1 , word_we $end
$var wire 1 - writeenable $end
$var wire 1 J xori $end
$var wire 1 K zero $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0K
0J
0I
0H
0G
1F
0E
b0 D
0C
0B
0A
0@
0?
0>
0=
0<
b100000 ;
b0 :
09
08
07
b10 6
05
14
03
02
01
00
b0 /
b100000 .
1-
0,
0+
0*
0)
0(
0'
b0 &
0%
0$
0#
b10 "
0!
$end
#10
b11 "
b11 6
04
1H
b100010 .
b100010 ;
#20
b100 "
b100 6
0H
1@
b100100 .
b100100 ;
#30
b101 "
b101 6
0@
1B
b100101 .
b100101 ;
#40
b110 "
b110 6
0B
1A
b100111 .
b100111 ;
#50
b111 "
b111 6
0A
1C
b100110 .
b100110 ;
#60
0'
1-
1#
1*
b10 "
b10 6
0C
b1000 /
b1000 D
0F
15
#70
b100 "
b100 6
b1100 /
b1100 D
05
17
#80
b101 "
b101 6
b1101 /
b1101 D
07
1E
#90
b111 "
b111 6
b1110 /
b1110 D
0E
1J
#100
0-
0#
0*
b11 "
b11 6
b100 /
b100 D
0J
18
#110
b1 &
b1 :
10
1K
#120
0'
00
0K
b101 /
b101 D
19
08
#130
b0 &
b0 :
10
1K
#140
b0 "
b0 6
b10 &
b10 :
b10 /
b10 D
09
1<
#150
1=
b11 &
b11 :
b1000 .
b1000 ;
b0 /
b0 D
1F
0<
#160
1-
1*
b0 &
b0 :
0=
b1111 /
b1111 D
0F
12
1(
#170
0*
b11 "
b11 6
1+
13
b101010 .
b101010 ;
b0 /
b0 D
1F
02
0(
#180
1#
b10 "
b10 6
1)
1*
0+
03
b100011 /
b100011 D
0F
1?
#190
b100100 /
b100100 D
0?
1>
1$
#200
0)
0-
0*
b101011 /
b101011 D
0>
0$
1I
1,
#210
b101000 /
b101000 D
0I
0,
1G
1%
#220
1-
1)
1!
11
0#
b101100 .
b101100 ;
b0 /
b0 D
1F
0G
0%
#230
