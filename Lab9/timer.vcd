$date
	Sun Mar 26 16:47:22 2017
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module timer_test $end
$var wire 1 ! TimerAddress $end
$var wire 1 " TimerInterrupt $end
$var wire 32 # cycle [31:0] $end
$var reg 1 $ MemRead $end
$var reg 1 % MemWrite $end
$var reg 32 & address [31:0] $end
$var reg 1 ' clock $end
$var reg 32 ( data [31:0] $end
$var reg 1 ) reset $end
$scope module t $end
$var wire 1 * Acknowledge $end
$var wire 32 + D [31:0] $end
$var wire 1 , MemRead $end
$var wire 1 - MemWrite $end
$var wire 32 . Q [31:0] $end
$var wire 32 / Q2 [31:0] $end
$var wire 1 0 Qequality $end
$var wire 1 ! TimerAddress $end
$var wire 1 " TimerInterrupt $end
$var wire 1 1 TimerRead $end
$var wire 1 2 TimerWrite $end
$var wire 32 3 address [31:0] $end
$var wire 1 4 cE1 $end
$var wire 1 5 cE6 $end
$var wire 1 6 clock $end
$var wire 32 7 cycle [31:0] $end
$var wire 32 8 data [31:0] $end
$var wire 1 9 reset $end
$var wire 1 : resettwo $end
$scope module cycleCounter $end
$var wire 1 6 clk $end
$var wire 32 ; d [31:0] $end
$var wire 1 < enable $end
$var wire 1 9 reset $end
$var reg 32 = q [31:0] $end
$upscope $end
$scope module aluadd $end
$var wire 3 > control [2:0] $end
$var wire 32 ? inA [31:0] $end
$var wire 32 @ inB [31:0] $end
$var wire 1 A negative $end
$var wire 32 B out [31:0] $end
$var wire 1 C zero $end
$upscope $end
$scope module interruptCycle $end
$var wire 1 6 clk $end
$var wire 32 D d [31:0] $end
$var wire 1 2 enable $end
$var wire 1 9 reset $end
$var reg 32 E q [31:0] $end
$upscope $end
$scope module timereadtri $end
$var wire 1 1 control $end
$var wire 32 F d [31:0] $end
$var wire 32 G o [31:0] $end
$upscope $end
$scope module interruptline $end
$var wire 1 6 clk $end
$var wire 1 H d $end
$var wire 1 0 enable $end
$var wire 1 : reset $end
$var reg 1 I q $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
xI
1H
bz G
bx F
bx E
b0 D
xC
bx B
xA
b1 @
bx ?
b0 >
bx =
1<
bx ;
1:
19
b0 8
bz 7
06
05
04
b0 3
02
01
x0
bx /
bx .
0-
0,
bx +
0*
1)
b0 (
0'
b0 &
0%
0$
bz #
x"
0!
$end
#5
0A
0C
b1 +
b1 ;
b1 B
b0 =
00
b0 .
b0 ?
b0 F
b11111111111111111111111111111111 E
b11111111111111111111111111111111 /
0I
0"
1'
16
#10
b0 #
b0 7
b0 G
11
1!
0:
0'
06
1$
1,
b11111111111111110000000000011100 &
b11111111111111110000000000011100 3
14
0)
09
#15
b10 +
b10 ;
b10 B
b1 #
b1 7
b1 G
b1 =
b1 .
b1 ?
b1 F
1'
16
#20
0'
06
#25
b11 +
b11 ;
b11 B
b10 #
b10 7
b10 G
b10 =
b10 .
b10 ?
b10 F
1'
16
#30
0'
06
#35
b100 +
b100 ;
b100 B
b11 #
b11 7
b11 G
b11 =
b11 .
b11 ?
b11 F
1'
16
#40
0'
06
#45
b101 +
b101 ;
b101 B
b100 #
b100 7
b100 G
b100 =
b100 .
b100 ?
b100 F
1'
16
#50
bz #
bz 7
bz G
12
01
0'
06
1%
1-
0$
0,
b110 (
b110 8
b110 D
#55
b110 +
b110 ;
b110 B
b110 E
b110 /
b101 =
b101 .
b101 ?
b101 F
1'
16
#60
b101 #
b101 7
b101 G
02
11
0'
06
0%
0-
1$
1,
#65
b111 +
b111 ;
b111 B
b110 #
b110 7
b110 G
b110 =
10
b110 .
b110 ?
b110 F
1'
16
#70
0'
06
#75
b1000 +
b1000 ;
b1000 B
b111 #
b111 7
b111 G
1I
1"
b111 =
00
b111 .
b111 ?
b111 F
1'
16
#80
0'
06
#85
b1001 +
b1001 ;
b1001 B
b1000 #
b1000 7
b1000 G
b1000 =
b1000 .
b1000 ?
b1000 F
1'
16
#90
0'
06
#95
b1010 +
b1010 ;
b1010 B
b1001 #
b1001 7
b1001 G
b1001 =
b1001 .
b1001 ?
b1001 F
1'
16
#100
bz #
bz 7
bz G
1:
01
1*
0'
06
1%
1-
0$
0,
b11111111111111110000000001101100 &
b11111111111111110000000001101100 3
04
15
#105
b1011 +
b1011 ;
b1011 B
b1010 =
b1010 .
b1010 ?
b1010 F
0I
0"
1'
16
#110
0'
06
